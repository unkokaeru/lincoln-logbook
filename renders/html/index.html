<p><em>‚ÄúI confirm that this logbook is entirely my own work and that all references and quotations, from both primary and secondary sources, have been fully identified and properly acknowledged.‚Äù</em> - William Fayers (27378661).</p>
<hr />
<h2 id="table-of-contents">üìö Table of Contents</h2>
<table>
<thead>
<tr class="header">
<th><strong>Section</strong></th>
<th><strong>Page</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Disclaimer</strong></td>
<td>1</td>
</tr>
<tr class="even">
<td><a href="#week-1-2024-09-30-to-2024-10-07"><strong>Week 1</strong> ‚Äì 2024-09-30 to 2024-10-07</a></td>
<td>2</td>
</tr>
<tr class="odd">
<td>¬†¬†¬†¬†1.1 <a href="#basic-use-using-cout">Basic Use: Using Cout</a></td>
<td>2</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†1.2 <a href="#basic-use-special-characters">Basic Use: Special Characters</a></td>
<td>3</td>
</tr>
<tr class="odd">
<td>¬†¬†¬†¬†1.3 <a href="#basic-use-pascals-triangle">Basic Use: Pascals Triangle</a></td>
<td>4</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†<em>1.4 <a href="#pascal-triangle-extended-project">Pascal Triangle: Extended Project</a></em></td>
<td>5</td>
</tr>
<tr class="odd">
<td><a href="#week-2-2024-10-07-to-2024-10-14"><strong>Week 2</strong> ‚Äì 2024-10-07 to 2024-10-14</a></td>
<td>6</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†2.1 <a href="#basic-use-variables-and-data-types">Basic Use: Variables And Data Types</a></td>
<td>6</td>
</tr>
<tr class="odd">
<td>¬†¬†¬†¬†2.2 <a href="#basic-use-input-and-math">Basic Use: Input And Math</a></td>
<td>7</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†<em>2.3 <a href="#coursework-calculator">Coursework: Calculator</a></em></td>
<td>8</td>
</tr>
<tr class="odd">
<td><a href="#week-3-2024-10-14-to-2024-10-21"><strong>Week 3</strong> ‚Äì 2024-10-14 to 2024-10-21</a></td>
<td>9</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†3.1 <a href="#basic-use-data-size">Basic Use: Data Size</a></td>
<td>9</td>
</tr>
<tr class="odd">
<td>¬†¬†¬†¬†3.2 <a href="#libraries-using-cmath">Libraries: Using Cmath</a></td>
<td>10</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†<em>3.3 <a href="#coursework-trig-calculator">Coursework: Trig Calculator</a></em></td>
<td>11</td>
</tr>
<tr class="odd">
<td><a href="#week-4-2024-10-21-to-2024-10-28"><strong>Week 4</strong> ‚Äì 2024-10-21 to 2024-10-28</a></td>
<td>12</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†4.1 <a href="#control-structures-if-else-statements">Control Structures: If Else Statements</a></td>
<td>12</td>
</tr>
<tr class="odd">
<td>¬†¬†¬†¬†4.2 <a href="#control-structures-input-validation">Control Structures: Input Validation</a></td>
<td>13</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†4.3 <a href="#control-structures-simple-calculator">Control Structures: Simple Calculator</a></td>
<td>14</td>
</tr>
<tr class="odd">
<td>¬†¬†¬†¬†<em>4.4 <a href="#coursework-quadratic-calculator">Coursework: Quadratic Calculator</a></em></td>
<td>15</td>
</tr>
<tr class="even">
<td><a href="#week-5-2024-10-28-to-2024-11-04"><strong>Week 5</strong> ‚Äì 2024-10-28 to 2024-11-04</a></td>
<td>16</td>
</tr>
<tr class="odd">
<td>¬†¬†¬†¬†5.1 <a href="#control-structures-switch-statements">Control Structures: Switch Statements</a></td>
<td>16</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†5.2 <a href="#control-structures-while-loops">Control Structures: While Loops</a></td>
<td>17</td>
</tr>
<tr class="odd">
<td>¬†¬†¬†¬†5.3 <a href="#algorithms-babylonian-square-root">Algorithms: Babylonian Square Root</a></td>
<td>18</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†<em>5.4 <a href="#coursework-variable-manipulation">Coursework: Variable Manipulation</a></em></td>
<td>19</td>
</tr>
<tr class="odd">
<td><a href="#week-6-2024-11-04-to-2024-11-11"><strong>Week 6</strong> ‚Äì 2024-11-04 to 2024-11-11</a></td>
<td>20</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†6.1 <a href="#control-structures-for-loops">Control Structures: For Loops</a></td>
<td>20</td>
</tr>
<tr class="odd">
<td>¬†¬†¬†¬†6.2 <a href="#functions-introduction">Functions: Introduction</a></td>
<td>21</td>
</tr>
<tr class="even">
<td><a href="#week-7-2024-11-11-to-2024-11-18"><strong>Week 7</strong> ‚Äì 2024-11-11 to 2024-11-18</a></td>
<td>22</td>
</tr>
<tr class="odd">
<td>¬†¬†¬†¬†7.1 <a href="#pointers-introduction">Pointers: Introduction</a></td>
<td>22</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†7.2 <a href="#pointers-quadratic-calculator">Pointers: Quadratic Calculator</a></td>
<td>23</td>
</tr>
<tr class="odd">
<td><a href="#week-8-2024-11-18-to-2024-11-25"><strong>Week 8</strong> ‚Äì 2024-11-18 to 2024-11-25</a></td>
<td>24</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†8.1 <a href="#applications-quadratic-calculator">Applications: Quadratic Calculator</a></td>
<td>24</td>
</tr>
<tr class="odd">
<td>¬†¬†¬†¬†8.2 <a href="#applications-maclaurin">Applications: Maclaurin</a></td>
<td>25</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†8.3 <a href="#applications-array-copy-check">Applications: Array Copy Check</a></td>
<td>26</td>
</tr>
<tr class="odd">
<td><a href="#week-9-2024-11-25-to-2024-12-02"><strong>Week 9</strong> ‚Äì 2024-11-25 to 2024-12-02</a></td>
<td>27</td>
</tr>
<tr class="even">
<td>¬†¬†¬†¬†9.1 <a href="#file-handling-overview">File Handling: Overview</a></td>
<td>27</td>
</tr>
<tr class="odd">
<td><strong><a href="#references">References</a></strong></td>
<td>28</td>
</tr>
</tbody>
</table>
<h2 id="week-1-2024-09-30-to-2024-10-07"><strong>Week 1</strong> ‚Äì 2024-09-30 to 2024-10-07</h2>
<p><strong>What did you learn in the lab tasks this week?</strong></p>
<p>In the lab session this week we focused on outputting to a data stream and handling special characters. In order to output to a data stream, I learned we use <code>cout</code> to declare console output and insert data into this with the insertion operator, <code>&lt;&lt;</code> - this differs from Python‚Äôs <code>print</code> function, but is essentially how it works. This is because C++ is a lower level language, just above assembly code, and is thus more lightweight and efficient, e.g.¬†you don‚Äôt need input/output capabilities with all programs, as not all programs need a command-line interface, hence we include the line <code>#include &lt;iostream&gt;</code>to access these stream commands.</p>
<p>Additionally, we explored special characters (<code>\n</code>, <code>\a</code>, <code>\b</code>, <code>\f</code>, <code>\r</code>, and <code>\t</code>), escape sequences (<code>\\</code>, <code>\'</code>, <code>\"</code>, and <code>\?</code>), and the line terminator (<code>endl</code>). The special characters and escape sequences are similar to those used in Python, but the line terminator was completely new for me. Functionally, it seems to act the same as a newline character, but works by ending the data stream started by <code>cout</code>.</p>
<p><strong>How well did I learn it?</strong></p>
<p>I learned everything pretty quickly, making parallels with Python quite often. It‚Äôs been really fun learning a completely new, more low-level language and deepening my understanding of programming in general. I did some extra work outside of my lab session, too, which definitely helped me reinforce any new knowledge and understand C++ even quicker.</p>
<p><strong>How does my solution compare with the official solution?</strong></p>
<p>The official solution for Task 3 adds an additional explanation of how Pascal‚Äôs triangle is obtained, as well as uses a simplified solution using spaces rather than tab characters.</p>
<p><strong>How can I extend the concepts used in the tasks to form a new project</strong></p>
<p>In my extra work this week, I‚Äôve extended the concepts used to make Pascal‚Äôs triangle by changing the logic to a more loop-based system so that I can use render any number of rows. I also tried an alternative to using the tab characters, <code>setd::setw</code>. Not only this, but I decided to take this number of rows as a user input with <code>std::cin</code> and validated the input, throwing an exception if invalid.</p>
<p>I also researched C++ best practices and styling guidelines, referencing documents like Google Style Guides <a href="#references">[1]</a> and Doxygen <a href="#references">[2]</a>. The main points are learned from this were: consistent comment style (I opted for /* and /**), function return rationale (i.e.¬†when to use <code>void</code>), explicitly returning 0 in a main function (to tell the console it ran correctly), docstring placement (before a function, contrasting with Python), and function declaration (placing the opening curly bracket on the same line).</p>
<p>Finally, with the project I already explained, I explored functions, for loops, conditional statements, exception handling, and some basic libraries: <code>cmath</code>, <code>stdexcept</code>, and <code>iomanip</code>.</p>
<p><strong>Lesson Review Question Answers</strong></p>
<ol type="1">
<li>Facilitates complex simulations; differs by enabling exploration beyond physical limits.</li>
<li>Climate modeling, drug discovery, astrophysics simulations.</li>
<li>First computer-assisted proof; raises questions about proof validity.</li>
<li>Cost/feasibility issues; safety concerns.</li>
<li>From serial to parallel computing; enhances computational power for complex problems.</li>
<li>Serial: sequential processing; Parallel: simultaneous processing.</li>
<li>Physical limits in miniaturization; heat dissipation, quantum effects.</li>
<li>FLOPS: Floating Point Operations Per Second; measures computational performance.</li>
<li>Binary: two digits (0, 1); used for electronic circuitry efficiency.</li>
<li>Encapsulation, inheritance, polymorphism.</li>
</ol>
<p>Multiple choice: BCCBCCBBBA</p>
<h3 id="basic-use-using-cout">Basic Use: Using Cout</h3>
<h4 id="task-1.5">Task 1.5</h4>
<p>The first bit of C++ code I‚Äôve ever written!</p>
<pre><code>cout &lt;&lt; &quot;Welcome to C++ Programming\n&quot;;</code></pre>
<h3 id="basic-use-special-characters">Basic Use: Special Characters</h3>
<h4 id="task-2.3">Task 2.3</h4>
<p>The bell character <code>\a</code> makes a sound in some environments.</p>
<pre><code>cout &lt;&lt; &quot;With bell character: Welcome to C++ Programming\a&quot; &lt;&lt; &quot;---\n&quot;;</code></pre>
<p>The backspace character  the last character.</p>
<pre><code>cout &lt;&lt; &quot;With backspace character: Welcome to C++ Programming\b&quot; &lt;&lt; &quot;---\n&quot;;</code></pre>
<p>The return character  to the start of the line.</p>
<pre><code>cout &lt;&lt; &quot;With return character: Welcome to C++ Programming\r&quot; &lt;&lt; &quot;---\n&quot;;</code></pre>
<p>The tab character  a tab space.</p>
<pre><code>cout &lt;&lt; &quot;With tab character: Welcome to C++ Programming\t&quot; &lt;&lt; &quot;---\n&quot;;</code></pre>
<h4 id="task-2.4">Task 2.4</h4>
<p>Removing the backslash before the single quote causes a syntax error.</p>
<pre><code>cout &lt;&lt; &quot;Escaped characters: Is the symbol \\n called \&#39; Newline \&#39; \? \n&quot;;</code></pre>
<h4 id="task-2.5">Task 2.5</h4>
<p>The line terminator <code>endl</code> starts a new line.</p>
<pre><code>cout &lt;&lt; &quot;A rose by any other name would smell as sweet&quot;;
cout &lt;&lt; endl;</code></pre>
<h3 id="basic-use-pascals-triangle">Basic Use: Pascals Triangle</h3>
<pre><code>/**
 * @file l03-basic_use-pascals_triangle.cpp
 * @author William Fayers (william@fayers.com)
 * @brief Exploring cout and special characters to print Pascal&#39;s Triangle.
 * @version 0.1.0
 * @date 2024-09-30
 * 
 * @copyright Copyright (c) 2024
 * 
 */
#include &lt;iostream&gt;

using namespace std;


/**
 * @brief Main function to run the program.
 * 
 * @return int Success or failure (0 or 1).
 */
int main() {
    /* Print Pascal&#39;s Triangle up to n=5 with cout and the tab character to center the numbers */
    cout &lt;&lt; &quot;n\t\t\t\t   Pascal&#39;s Triangle up to n=5\n&quot;;
    cout &lt;&lt; &quot;0\t\t\t\t\t\t1\n&quot;;
    cout &lt;&lt; &quot;1\t\t\t\t\t1\t\t1\n&quot;;
    cout &lt;&lt; &quot;2\t\t\t\t1\t\t2\t\t1\n&quot;;
    cout &lt;&lt; &quot;3\t\t\t1\t\t3\t\t3\t\t1\n&quot;;
    cout &lt;&lt; &quot;4\t\t1\t\t4\t\t6\t\t4\t\t1\n&quot;;
    cout &lt;&lt; &quot;5\t1\t\t5\t\t10\t\t10\t\t5\t\t1\n&quot;;

    cout &lt;&lt; &quot;\t\t\t\t      Made by William Fayers\n&quot;;
    /**
     * ANSWER (Task 3.1):
     * I used the tab character, `\t` to center the numbers in the Pascal&#39;s Triangle, along with
     * `cout` to print the numbers. This ended up with a fairly nice looking Pascal&#39;s Triangle.
     */

    /* Return 0 to indicate the program ran successfully */
    return 0;
}</code></pre>
<h3 id="pascal-triangle-extended-project">Pascal Triangle: Extended Project</h3>
<pre><code>/**
 * @file e01-pascal_triangle-extended_project.cpp
 * @author William Fayers (william@fayers.com)
 * @brief Outputs Pascal&#39;s triangle to the console, extending the concepts from lab 1.
 * @version 0.1.0
 * @date 2024-10-01
 * 
 * @copyright Copyright (c) 2024
 * 
 */

#include &lt;iostream&gt; /* For std::cout, std::cin */
#include &lt;cmath&gt; /* For std::ceil, std::pow */
#include &lt;stdexcept&gt; /* For std::invalid_argument */
#include &lt;iomanip&gt; /* For std::setw */


const int MAX_ROWS = 29;
const std::string ERROR_MESSAGE = &quot;Error: rows must be between 0 and &quot;
                                    + std::to_string(MAX_ROWS) + &quot;!&quot;;

/**
 * @brief Outputs Pascal&#39;s triangle to the console.
 * 
 * @details Calculates Pascal&#39;s triangle iteratively using the formula:
 * \f[
 * C(n, k+1) = C(n, k) \times \frac{n - k}{k + 1}
 * \f]
 * where \f$C(n, k)\f$ is the coefficient at row \f$n\f$ and column \f$k\f$.
 * Ensures the triangle is centered in the console by calculating the maximum
 * width of the triangle and the maximum width of the coefficients, using the
 * power of 2 to estimate the width of the largest coefficient.
 * 
 * @note Designed to test the use of output streams, loops, error handling, libraries,
 * and functions in C++. Extends the concepts from lab 1, exploring new concepts
 * like using the `std::setw` function to set the width of the output instead of
 * using the tab character.
 * 
 * @param rows The number of rows to output in Pascal&#39;s triangle. Must be non-negative
 * and less than or equal to MAX_ROWS.
 *
 * @throw std::invalid_argument Throws an error if rows is less than 0 or greater than MAX_ROWS.
 *
 * @warning Since the coefficients in Pascal&#39;s triangle can grow very large, this
 * function may not work as expected for rows greater than 29.
 *
 * @example
 * \code{.cpp}
 * output_pascals_triangle(4);
 * \endcode
 *
 * Expected Output:
 * \code{.plaintext}
 *     1
 *    1 1
 *   1 2 1
 *  1 3 3 1
 * 1 4 6 4 1
 * \endcode
 */
void output_pascals_triangle(int rows) {
    /* Throw an error if rows is less than 0 or greater than MAX_ROWS. */
    if (rows &lt; 0 || rows &gt; MAX_ROWS) {
        throw std::invalid_argument(ERROR_MESSAGE);
    }

    /* Estimate the width of the largest coefficient using the power of 2 */
    int estimated_max_coefficient = std::ceil(std::pow(2, rows));
    int max_coefficient_width = std::to_string(estimated_max_coefficient).length() + 1;

    /* Calculate the maximum width of the triangle. */
    int max_triangle_width = max_coefficient_width * (rows + 1);

    /* Loop through each row in Pascal&#39;s triangle. */
    for (int row = 0; row &lt;= rows; row++) {
        /* Set the first coefficient to 1 */
        int coefficient = 1;

        /* Add leading spaces to center the triangle. */
        int leading_spaces = (max_triangle_width - (max_coefficient_width * (row + 1))) / 2;
        std::cout &lt;&lt; std::string(leading_spaces, &#39; &#39;);

        /* Loop through each column in the current row. */
        for (int column = 0; column &lt;= row; column++) {
            /* Output the current coefficient. */
            std::cout &lt;&lt; std::setw(max_coefficient_width) &lt;&lt; coefficient;

            /* Calculate the next coefficient. */
            coefficient = coefficient * (row - column) / (column + 1);
        }

        /* Move to the next row. */
        std::cout &lt;&lt; std::endl;
    }
}

/**
 * @brief Main function to run the program.
 *
 * @details This function prompts the user for the number of rows to output
 * in Pascal&#39;s triangle and calls the output_pascals_triangle function.
 *
 * @return Returns 0 to indicate the program has run successfully.
 */
int main() {
    /* Prompt the user for the number of rows to output. */
    std::cout &lt;&lt; &quot;Please enter the number of rows you would like to output (0 to &quot;
                &lt;&lt; MAX_ROWS &lt;&lt; &quot;): &quot;;
    int rows;
    std::cin &gt;&gt; rows;

    /* Output Pascal&#39;s triangle to the console. */
    try {
        output_pascals_triangle(rows);
    } catch (const std::invalid_argument&amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    /* Output a goodbye message to the user. */
    std::cout &lt;&lt; &quot;Made by William Fayers :)&quot; &lt;&lt; std::endl;

    /* Return 0 to indicate the function has run successfully. */
    return 0;
}</code></pre>
<h2 id="week-2-2024-10-07-to-2024-10-14"><strong>Week 2</strong> ‚Äì 2024-10-07 to 2024-10-14</h2>
<p><strong>What did you learn in the lab tasks this week?</strong></p>
<p>This week we explored variables and their data types a bit more, as well as how to use inputs and mathematics to prototype a simple calculator.</p>
<p><strong>How well did I learn it?</strong></p>
<p>As I already spent last week diving into C++ a lot more, this week was very simple, so I tried to extend the task solutions slightly with error handling etc.</p>
<p>Making great progress so far!</p>
<p><strong>How does my solution compare with the official solution?</strong></p>
<p>Task 2.2‚Äôs first offical solution differs the most by inputting the two numbers in one line, rather than separately.</p>
<p>The second official solution to Task 2.2 is a little bit more different, simplifying the programming techniques used. For example, it doesn‚Äôt handle any errors and doesn‚Äôt use a separate functionto handle any calculations.</p>
<p><strong>How can I extend the concepts used in the tasks to form a new project</strong></p>
<p>To extend these concepts, I could create a fully functional calculator with verbose error/input handling, which could even be extended to evaluate simple LaTeX expressions.</p>
<h3 id="basic-use-variables-and-data-types">Basic Use: Variables And Data Types</h3>
<h4 id="task-1.2">Task 1.2</h4>
<p>Declare and initalise the variables</p>
<pre><code>int total_children = 10;
int candies_per_child = 5;
int extra_candies = 10;</code></pre>
<p>Output the starting values and the total number of candies</p>
<pre><code>std::cout &lt;&lt; &quot;HALLOWEEN CANDY CALCULATOR&quot; &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Total Children: &quot; &lt;&lt; total_children &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Candies per Child: &quot; &lt;&lt; candies_per_child &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Extra Candies: &quot; &lt;&lt; extra_candies &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;---&quot; &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Total Candies: &quot; &lt;&lt; total_candies &lt;&lt; std::endl;</code></pre>
<p>Return 0 to indicate the program ran successfully</p>
<pre><code>return 0;</code></pre>
<h3 id="basic-use-input-and-math">Basic Use: Input And Math</h3>
<h4 id="task-2.1">Task 2.1</h4>
<p>Calculate the quotient on top of the given code for completion.</p>
<pre><code>result = number1 / number2;
std::cout &lt;&lt; &quot;Quotient: &quot; &lt;&lt; result &lt;&lt; std::endl;</code></pre>
<h4 id="task-2.3-1">Task 2.3</h4>
<p>Declare variables to store the masses and distance.</p>
<pre><code>float mass1, mass2, distance;</code></pre>
<p>We then input the masses and distance.</p>
<pre><code>std::cout &lt;&lt; &quot;Enter the mass of the first object (kg): &quot;;
std::cin &gt;&gt; mass1;
std::cout &lt;&lt; &quot;Enter the mass of the second object (kg): &quot;;
std::cin &gt;&gt; mass2;
std::cout &lt;&lt; &quot;Enter the distance between the objects (m): &quot;;
std::cin &gt;&gt; distance;</code></pre>
<p>And finally we call the function, catching any exceptions that occur.</p>
<pre><code>try {
float force = calculate_gravitational_force(mass1, mass2, distance);
std::cout &lt;&lt; &quot;Gravitational Force: &quot; &lt;&lt; force &lt;&lt; &quot; N&quot; &lt;&lt; std::endl;
} catch (std::invalid_argument&amp; error) {
std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; error.what() &lt;&lt; std::endl;
}</code></pre>
<h3 id="coursework-calculator">Coursework: Calculator</h3>
<h4 id="task-1.1">Task 1.1</h4>
<p>Input the radius of the circle.</p>
<pre><code>float radius;
input_number(radius, &quot;Enter the radius of the circle: &quot;);</code></pre>
<p>Calculate the area and circumference of the circle.</p>
<pre><code>float area = M_PI * radius * radius;
float circumference = 2 * M_PI * radius;
std::cout &lt;&lt; &quot;Area of a circle with radius &quot; &lt;&lt; radius &lt;&lt; &quot; = &quot; &lt;&lt; area &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Circumference of a circle with radius &quot; &lt;&lt; radius &lt;&lt; &quot; = &quot; &lt;&lt; circumference
&lt;&lt; std::endl;</code></pre>
<h4 id="task-1.2-1">Task 1.2</h4>
<p>Input the principal amount, rate of interest, and time period.</p>
<pre><code>float principal, rate, time;
input_number(principal, &quot;Enter the principal amount: &quot;);
input_number(rate, &quot;Enter the rate of interest (%): &quot;);
input_number(time, &quot;Enter the time period (years): &quot;);</code></pre>
<p>Calculate the simple interest.</p>
<pre><code>float simple_interest = (principal * rate * time) / 100;
std::cout &lt;&lt; &quot;Simple Interest on a principal amount of &quot; &lt;&lt; principal &lt;&lt; &quot; at a rate of &quot;
&lt;&lt; rate &lt;&lt; &quot;% for &quot; &lt;&lt; time &lt;&lt; &quot; years = &quot; &lt;&lt; simple_interest &lt;&lt; std::endl;</code></pre>
<h4 id="task-2.1-1">Task 2.1</h4>
<p>False, they are stored as binary numbers.</p>
<pre><code>return 0;
}

</code></pre>
<h4 id="task-2.2">Task 2.2</h4>
<p>Device.</p>
<pre><code></code></pre>
<h4 id="task-2.3-2">Task 2.3</h4>
<p><code>.cpp</code> extension.</p>
<pre><code></code></pre>
<h4 id="task-2.4-1">Task 2.4</h4>
<p>Translate source code into machine readable code (or exectuable program) that the computer can run.</p>
<pre><code></code></pre>
<h4 id="task-2.5-1">Task 2.5</h4>
<p>8 bits.</p>
<pre><code></code></pre>
<h4 id="task-2.6">Task 2.6</h4>
<p>Hexadecimal (base 16).</p>
<pre><code></code></pre>
<h4 id="task-2.7">Task 2.7</h4>
<p><span class="math inline">15‚ÄÖ*‚ÄÖ16<sup>5</sup>‚ÄÖ+‚ÄÖ10‚ÄÖ*‚ÄÖ16<sup>4</sup>‚ÄÖ+‚ÄÖ12‚ÄÖ*‚ÄÖ16<sup>3</sup>‚ÄÖ+‚ÄÖ10‚ÄÖ*‚ÄÖ16<sup>2</sup>‚ÄÖ+‚ÄÖ13‚ÄÖ*‚ÄÖ16<sup>1</sup>‚ÄÖ+‚ÄÖ14‚ÄÖ*‚ÄÖ16<sup>0</sup>‚ÄÑ=‚ÄÑ16435934</span>.</p>
<pre><code></code></pre>
<h4 id="task-2.8">Task 2.8</h4>
<p>True.</p>
<pre><code></code></pre>
<h4 id="task-2.9">Task 2.9</h4>
<p><code>cout</code> is used without the namespace <code>std</code>, and line 5 is missing a semicolon at the end of the line.</p>
<pre><code></code></pre>
<h4 id="task-2.10">Task 2.10</h4>
<p>Missing the insertion operator on line 8, correct line is <code>cin &gt;&gt; num1 &gt;&gt; num2;</code></p>
<pre><code></code></pre>
<h2 id="week-3-2024-10-14-to-2024-10-21"><strong>Week 3</strong> ‚Äì 2024-10-14 to 2024-10-21</h2>
<p><strong>What did you learn in the lab tasks this week?</strong></p>
<p>We learned more about data types, specifically how they‚Äôre handled in memory and their sizes. On top of this, we started using the cmath library for more complex calculations.</p>
<p><strong>How well did I learn it?</strong></p>
<p>It was quite simple to learn, and interesting to learn more about the lower-level hardware parts, too. It was slightly confusing answering the questions because of a few minor mistakes in the actual questions and example code, but apart from that I learned it all well!</p>
<p><strong>How does my solution compare with the official solution?</strong></p>
<p>The official solutions for Task 2.2 are similar to mine, although handled numbers like 1. instead of 1.0 - this seems very confusing to me. It also wrote each expression in one long line, rather than breaking it across multiple with whitespace. The second expression is also incorrectly evaluated as not a real number in the offical solution.</p>
<p>The final part of this week‚Äôs lab also added more than the question asked for, but so did I with error handling!</p>
<h3 id="basic-use-data-size">Basic Use: Data Size</h3>
<h4 id="task-1.1-1">Task 1.1</h4>
<p>After reaching the max value of the data type, the number goes to zero.</p>
<pre><code>std::cout &lt;&lt; &quot;Original number: &quot; &lt;&lt; unsigned_small_number &lt;&lt; std::endl;
unsigned_small_number++;
std::cout &lt;&lt; &quot;Incremented number (1x): &quot; &lt;&lt; unsigned_small_number &lt;&lt; std::endl;
unsigned_small_number++;
std::cout &lt;&lt; &quot;Incremented number (2x): &quot; &lt;&lt; unsigned_small_number &lt;&lt; std::endl;</code></pre>
<h4 id="task-1.3">Task 1.3</h4>
<p>Similar to overflow, it loops around as an underflow.</p>
<pre><code>signed_small_number = -32768;
std::cout &lt;&lt; &quot;Original number: &quot; &lt;&lt; signed_small_number &lt;&lt; std::endl;
signed_small_number--;
std::cout &lt;&lt; &quot;Decremented number (1x): &quot; &lt;&lt; signed_small_number &lt;&lt; std::endl;
signed_small_number--;
std::cout &lt;&lt; &quot;Decremented number (2x): &quot; &lt;&lt; signed_small_number &lt;&lt; std::endl;</code></pre>
<h3 id="libraries-using-cmath">Libraries: Using Cmath</h3>
<h4 id="task-2.1-2">Task 2.1</h4>
<p>Calculate the square root of 9.0, which resulted in 3.</p>
<pre><code>std::cout &lt;&lt; sqrt(9.0) &lt;&lt; std::endl;</code></pre>
<p>Calculate the natural logarithm of 1.1, which resulted in 0.0953102.</p>
<pre><code>std::cout &lt;&lt; log(1.1) &lt;&lt; std::endl;</code></pre>
<p>Calculate 2.5 raised to the power of 3.0, which resulted in 15.625.</p>
<pre><code>std::cout &lt;&lt; pow(2.5, 3.0) &lt;&lt; std::endl;</code></pre>
<p>Calculate the ceiling of 4.1, which resulted in 5.</p>
<pre><code>std::cout &lt;&lt; ceil(4.1) &lt;&lt; std::endl;</code></pre>
<p>Calculate (7 + sqrt(7.0)) / 3.0, which resulted in 3.21525.</p>
<pre><code>std::cout &lt;&lt; (7 + sqrt(7.0)) / 3.0 &lt;&lt; std::endl;</code></pre>
<p>Calculate the hyperbolic tan of 0.342, which resulted in 0.329262</p>
<pre><code>std::cout &lt;&lt; tanh(0.342) &lt;&lt; std::endl;</code></pre>
<p>Calculate the remainder of 11.0 divided by 4.0, which resulted in 3.</p>
<pre><code>std::cout &lt;&lt; fmod(11.0, 4.0) &lt;&lt; std::endl;</code></pre>
<p>Calculate the absolute value of -9, which resulted in 9.</p>
<pre><code>std::cout &lt;&lt; abs(-9) &lt;&lt; std::endl;</code></pre>
<p>Calculate the (floating) absolute value of -4.5, which resulted in 4.5.</p>
<pre><code>std::cout &lt;&lt; fabs(-4.5) &lt;&lt; std::endl;</code></pre>
<p>Calculate the floor of 8.8, which resulted in 8.</p>
<pre><code>std::cout &lt;&lt; floor(8.8) &lt;&lt; std::endl;</code></pre>
<p>Calculate the base-10 logarithm of 1.0, which resulted in 0.</p>
<pre><code>std::cout &lt;&lt; log10(1.0) &lt;&lt; std::endl;</code></pre>
<p>Calculate the cube root of 10.0, which resulted in 2.15443.</p>
<pre><code>std::cout &lt;&lt; cbrt(10.0) &lt;&lt; std::endl;</code></pre>
<h4 id="task-2.3-3">Task 2.3</h4>
<p>Prompt the user for a value of x.</p>
<pre><code>double x;
std::cout &lt;&lt; &quot;Calculation of the hyperbolic cosecant function...&quot; &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Enter a value for x: &quot;;
std::cin &gt;&gt; x;</code></pre>
<p>Calculate the hyperbolic cosecant of x using the custom csch function.</p>
<pre><code>double y = csch(x);
if (!std::isnan(y)) {
std::cout &lt;&lt; &quot;Hyperbolic cosecant of &quot; &lt;&lt; x &lt;&lt; &quot; is: &quot; &lt;&lt; y &lt;&lt; std::endl;
} else {
std::cout &lt;&lt; &quot;Hyperbolic cosecant is undefined for x = 0.&quot; &lt;&lt; std::endl;
}</code></pre>
<h3 id="coursework-trig-calculator">Coursework: Trig Calculator</h3>
<h4 id="task-3.0">Task 3.0</h4>
<p>Start with a verbose number input function to re-use.</p>
<pre><code>void input_number(double&amp; number, const std::string&amp; input_message) {
while (true) {
std::cout &lt;&lt; input_message;
std::cin &gt;&gt; number;

if (std::cin.fail()) {
std::cerr &lt;&lt; &quot;Invalid input. Please enter a valid number.&quot; &lt;&lt; std::endl;
std::cin.clear();
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);
} else {
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);
return;
}
}
}</code></pre>
<p>Implement the main program loop with the atanh and acosh functions.</p>
<pre><code>int main() {
while (true) {
double choice;
std::cout &lt;&lt; &quot;Select an operation:\n1. Inverse Hyperbolic Tangent\n&quot;
&lt;&lt; &quot;2. Inverse Hyperbolic Cosine\n0. Exit\n&quot;;
input_number(choice, &quot;Enter your choice: &quot;);

if (choice == 0) {
break;
}

double x;
switch (static_cast&lt;int&gt;(choice)) {
case 1:
input_number(x, &quot;Enter a value for x (between -1 and 1): &quot;);
std::cout &lt;&lt; &quot;The inverse hyperbolic tangent of &quot; &lt;&lt; x &lt;&lt; &quot; is &quot; &lt;&lt; atanh(x)
&lt;&lt; std::endl;
break;
case 2:
input_number(x, &quot;Enter a value for x (greater than or equal to 1): &quot;);
std::cout &lt;&lt; &quot;The inverse hyperbolic cosine of &quot; &lt;&lt; x &lt;&lt; &quot; is &quot; &lt;&lt; acosh(x)
&lt;&lt; std::endl;
break;
default:
std::cerr &lt;&lt; &quot;Error: Invalid operation number.&quot; &lt;&lt; std::endl;
break;
}
}

return 0;
}</code></pre>
<h4 id="task-3.1">Task 3.1</h4>
<p>Implement the atanh function, with error checking.</p>
<pre><code>double atanh(double x) {
if (x &lt; -1 || x &gt; 1) {
std::cerr &lt;&lt; &quot;\nError: The input value must be between -1 and 1.&quot; &lt;&lt; std::endl;
return NAN;
}
return 0.5 * log((1 + x) / (1 - x));
}</code></pre>
<h4 id="task-3.2">Task 3.2</h4>
<p>Implement the acosh function, with error checking.</p>
<pre><code>double acosh(double x) {
if (x &lt; 1) {
std::cerr &lt;&lt; &quot;\nError: The input value must be greater than or equal to 1.&quot; &lt;&lt; std::endl;
return NAN;
}
return log(x + sqrt(x * x - 1));
}</code></pre>
<h4 id="task-4.1">Task 4.1</h4>
<p>bba.</p>
<pre><code>
</code></pre>
<h4 id="task-4.2">Task 4.2</h4>
<p>TTTT, although note for the third statement, technically the return statement can be implicit, but it‚Äôs always required even if it‚Äôs implicitly there.</p>
<pre><code></code></pre>
<h2 id="week-4-2024-10-21-to-2024-10-28"><strong>Week 4</strong> ‚Äì 2024-10-21 to 2024-10-28</h2>
<p><strong>What did you learn in the lab tasks this week?</strong></p>
<p>This lab we covered conditonal statements, input validation, and how we can apply these topics to a simple calculator.</p>
<p><strong>How well did I learn it?</strong></p>
<p>It was quite quick to learn everything because of the extra work I‚Äôve been doing, so yet again, I learned it pretty well!</p>
<p><strong>How does my solution compare with the official solution?</strong></p>
<p>Generally, both solutions are the same but mine has more error handling and separates things into more functions. For the final task, the official solution also added another function to be calculated, <code>sech(x)</code>, whereas I didn‚Äôt.</p>
<p><strong>How can I extend the concepts used in the tasks to form a new project</strong></p>
<p>I could extend the trigonometric ideas to make a fully functional trig calculator, with various different trigonometric functions to be evaluated.</p>
<h3 id="control-structures-if-else-statements">Control Structures: If Else Statements</h3>
<h4 id="task-1.1-2">Task 1.1</h4>
<p>Copy the function to calculate the first piecewise function.</p>
<pre><code>std::tuple&lt;double, double&gt; evaluate_function1(double x, double &amp;y) {
if (x &gt;= 2) {
std::cout &lt;&lt; &quot;x is greater than or equal to 2, so \n&quot;;
std::cout &lt;&lt; &quot;y = x^3 + sqrt(x) = &quot;;
y = pow(x, 3) + sqrt(x);
} else if (x &gt; 0.5 &amp;&amp; x &lt; 2) {
std::cout &lt;&lt; &quot;x is between 0.5 and 2, so \n&quot;;
std::cout &lt;&lt; &quot;y = 1 - exp(x) = &quot;;
y = 1 - exp(x);
} else {
std::cout &lt;&lt; &quot;x is less than or equal to 0.5, so \n&quot;;
std::cout &lt;&lt; &quot;y = |x + 5| = &quot;;
y = fabs(x + 5);
}

return std::make_tuple(x, y);
}</code></pre>
<h4 id="task-1.3-1">Task 1.3</h4>
<p>Evaluate the second piecewise function.</p>
<pre><code>std::tuple&lt;double, double&gt; evaluate_function2(double x, double &amp;y) {
if (x &lt; -M_PI/2) {
std::cout &lt;&lt; &quot;x is less than -pi/2, so \n&quot;;
std::cout &lt;&lt; &quot;y = -1 - pi/2 = &quot;;
y = -1 - M_PI/2;
} else if (x &gt;= -M_PI/2 &amp;&amp; x &lt;= 0) {
std::cout &lt;&lt; &quot;x is between -pi/2 and 0, so \n&quot;;
std::cout &lt;&lt; &quot;y = sin(x) + x = &quot;;
y = sin(x) + x;
} else {
std::cout &lt;&lt; &quot;x is greater than 0, so \n&quot;;
std::cout &lt;&lt; &quot;y = x = &quot;;
y = x;
}

return std::make_tuple(x, y);
}</code></pre>
<h3 id="control-structures-input-validation">Control Structures: Input Validation</h3>
<h4 id="task-2.0">Task 2.0</h4>
<p>Initalises the constant variables.</p>
<pre><code>const double banned_number = 2.0;
const double small_number = 10e-12;</code></pre>
<p>Fetch input from the user.</p>
<pre><code>double x;
std::cout &lt;&lt; &quot;Enter a value for x (other than 2.0): &quot;;
std::cin &gt;&gt; x;</code></pre>
<p>Calculate the function and output the result.</p>
<pre><code>cout &lt;&lt; &quot;When x = &quot; &lt;&lt; x &lt;&lt; &quot;, the function y = 1/(x^2 - 2) is equal to &quot;;
double y = 1 / (std::pow(x, 2.0) - 2.0);
cout &lt;&lt; y &lt;&lt; endl;</code></pre>
<h3 id="control-structures-simple-calculator">Control Structures: Simple Calculator</h3>
<h4 id="task-3.0-1">Task 3.0</h4>
<p>Create a function to input a number, avoiding a banned number.</p>
<pre><code>void input_number(const std::string &amp;input_message, double &amp;number, const double &amp;banned_number){
const double float_error_resolution = 10e-12;

while (true){
std::cout &lt;&lt; input_message;
std::cin &gt;&gt; number;

if (std::cin.fail()){
std::cerr &lt;&lt; &quot;Invalid input. Please enter a valid number.&quot; &lt;&lt; std::endl;
std::cin.clear();
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);
} else if (std::fabs(number - banned_number) &lt; float_error_resolution){
std::cerr &lt;&lt; &quot;Error: x cannot be &quot; &lt;&lt; banned_number &lt;&lt; std::endl;
std::cin.clear();
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);
} else {
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);
return;
}
}
}</code></pre>
<p>Loop selection until the user exits.</p>
<pre><code>while (true) {
std::cout &lt;&lt; &quot;List of functions:&quot; &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;0. Exit&quot; &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;1. csch(x)&quot; &lt;&lt; std::endl;

int choice;
std::cout &lt;&lt; &quot;Enter the number of the function you would like to use: &quot;;
std::cin &gt;&gt; choice;
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);
std::cout &lt;&lt; &quot;---&quot; &lt;&lt; std::endl;

double x, y;
switch (choice){
case 0:
std::cout &lt;&lt; &quot;Exiting...&quot; &lt;&lt; std::endl;
return 0;
case 1:
input_number(&quot;Enter x: &quot;, x, 0.0);
std::cout &lt;&lt; &quot;csch(&quot; &lt;&lt; x &lt;&lt; &quot;) = &quot;;
y = 1.0 / std::sinh(x);
break;
default:
std::cerr &lt;&lt; &quot;Invalid choice. Please enter a valid number.&quot; &lt;&lt; std::endl;
y = NAN;
break;
}

if (!std::isnan(y)){
std::cout &lt;&lt; y &lt;&lt; std::endl;
}
}</code></pre>
<h3 id="coursework-quadratic-calculator">Coursework: Quadratic Calculator</h3>
<h4 id="task-5.0">Task 5.0</h4>
<p>Include the necessary libraries.</p>
<pre><code>#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;tuple&gt;</code></pre>
<p>Start with a verbose number input function to re-use.</p>
<pre><code>void input_number(double&amp; number, const std::string&amp; input_message) {
while (true) {
std::cout &lt;&lt; input_message;
std::cin &gt;&gt; number;

if (std::cin.fail()) {
std::cerr &lt;&lt; &quot;Invalid input. Please enter a valid number.&quot; &lt;&lt; std::endl;
std::cin.clear();
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);
} else {
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);
return;
}
}
}</code></pre>
<p>Calculate the quadratic‚Äôs solution.</p>
<pre><code>std::tuple&lt;double, double&gt; solve_quadratic(const double a, const double b, const double c) {
double discriminant = pow(b, 2) - 4 * a * c;
if (discriminant &lt; 0) {
return std::make_tuple(NAN, NAN);
}

double x1 = (-b + sqrt(discriminant)) / (2 * a);
double x2 = (-b - sqrt(discriminant)) / (2 * a);

return std::make_tuple(x1, x2);
}</code></pre>
<p>Implement the main program loop.</p>
<pre><code>int main() {
while (true) {
double a, b, c;
input_number(a, &quot;Enter the coefficient of x^2: &quot;);
input_number(b, &quot;Enter the coefficient of x: &quot;);
input_number(c, &quot;Enter the constant term: &quot;);

std::tuple&lt;double, double&gt; x = solve_quadratic(a, b, c);

std::cout &lt;&lt; &quot;The quadratic equation &quot; &lt;&lt; a &lt;&lt; &quot;x^2 + &quot; &lt;&lt; b &lt;&lt; &quot;x + &quot; &lt;&lt; c &lt;&lt; &quot; = 0 has &quot;;

if (std::isnan(std::get&lt;0&gt;(x))) {
std::cout &lt;&lt; &quot;no real solutions.&quot; &lt;&lt; std::endl;
} else if (std::get&lt;0&gt;(x) == std::get&lt;1&gt;(x)) {
std::cout &lt;&lt; &quot;one solution: x = &quot; &lt;&lt; std::get&lt;0&gt;(x)
&lt;&lt; std::endl;
} else {
std::cout &lt;&lt; &quot;two solutions: x = &quot; &lt;&lt; std::get&lt;0&gt;(x)
&lt;&lt; &quot; and x = &quot; &lt;&lt; std::get&lt;1&gt;(x) &lt;&lt; std::endl;
}

char response;
std::cout &lt;&lt; &quot;Would you like to solve another quadratic equation? (y/n): &quot;;
std::cin &gt;&gt; response;

if (response != &#39;y&#39;) {
break;
}
}

return 0;
}</code></pre>
<h2 id="week-5-2024-10-28-to-2024-11-04"><strong>Week 5</strong> ‚Äì 2024-10-28 to 2024-11-04</h2>
<p><strong>What did you learn in the lab tasks this week?</strong></p>
<p>This week we extended the statements we know with the switch and while statements, then applied those concepts to making an algorithm to find the Babylonian square root.</p>
<p><strong>How well did I learn it?</strong></p>
<p>I think I learned everything quite well, borrowing from my understanding of other programming languages really helped, too.</p>
<p><strong>How does my solution compare with the official solution?</strong></p>
<p>The offical solutions aren‚Äôt out yet, but I‚Äôll update this when they are - if they are in time for the logbook submission deadline.</p>
<p><strong>How can I extend the concepts used in the tasks to form a new project</strong></p>
<p>As similarly suggested in previous weeks, I could extend these concepts to make a fully functional calculator - maybe I will between semesters!</p>
<h3 id="control-structures-switch-statements">Control Structures: Switch Statements</h3>
<h4 id="task-1.1-3">Task 1.1</h4>
<p>Example switch statement.</p>
<pre><code>void example_switch_function() {
unsigned int incrementor = 3;
unsigned int number;

switch (incrementor) {
case 1:
number = 1;
break;
case 2:
number = 1;
break;
case 3:
number = 2;
break;
case 4:
number = 6;
break;
case 5:
number = 24;
break;
default:
number = 0;
break;
}

std::cout &lt;&lt; &quot;The number is: &quot; &lt;&lt; number &lt;&lt; std::endl;
}</code></pre>
<p>Call the example switch function.</p>
<pre><code>// example_switch_function(); // uncomment this line to run the example</code></pre>
<h4 id="task-1.2-2">Task 1.2</h4>
<p>Implement a switch statement to select a function.</p>
<pre><code>
const double small_number = 10e-12;
double x, y;
int selection;

std::cout &lt;&lt; &quot;FUNCTION LIST&quot; &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;1. csch(x)&quot; &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;2. sech(x)&quot; &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;3. coth(x)&quot; &lt;&lt; std::endl;

std::cout &lt;&lt; &quot;Select a function (1-3): &quot;;
std::cin &gt;&gt; selection;
if (selection &gt; 0 &amp;&amp; selection &lt; 4) {
std::cout &lt;&lt; &quot;Enter a value for x: &quot;;
std::cin &gt;&gt; x;
std::cout &lt;&lt; &quot;For x = &quot; &lt;&lt; x &lt;&lt; &quot;, &quot;;
}

switch (selection) {
case 1:
if (std::abs(x) &lt; small_number) {
std::cout &lt;&lt; &quot;csch(x) is undefined for x = 0.&quot; &lt;&lt; std::endl;
return 1;
}
y = 1/sinh(x);
std::cout &lt;&lt; &quot;csch(x) &quot;;
break;
case 2:
y = 1/cosh(x);
std::cout &lt;&lt; &quot;sech(x) &quot;;
break;
case 3:
if (std::abs(x) &lt; small_number) {
std::cout &lt;&lt; &quot;coth(x) is undefined for x = 0.&quot; &lt;&lt; std::endl;
return 1;
}
y = 1/tanh(x);
std::cout &lt;&lt; &quot;coth(x) &quot;;
break;
default:
std::cout &lt;&lt; &quot;Invalid selection.&quot; &lt;&lt; std::endl;
return 1;
}

std::cout &lt;&lt; &quot;= &quot; &lt;&lt; y &lt;&lt; std::endl;</code></pre>
<h3 id="control-structures-while-loops">Control Structures: While Loops</h3>
<h4 id="task-2.1-3">Task 2.1</h4>
<p>The precision is set to 10 decimal places.</p>
<pre><code>std::setprecision(10);</code></pre>
<p>The mean is calculated by dividing the sum by the number of values.</p>
<pre><code>double mean = sum / 6;</code></pre>
<p>Calculate the variance and hence standard deviation.</p>
<pre><code>double variance = ((sum_of_squares / 6) - (mean * mean)) * 6 / 5;
double standard_deviation = std::sqrt(variance);</code></pre>
<p>The calculated values are then outputted to the console.</p>
<pre><code>std::cout &lt;&lt; &quot;The minimum value is: &quot; &lt;&lt; min &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;The maximum value is: &quot; &lt;&lt; max &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;The mean value is: &quot; &lt;&lt; mean &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;The standard deviation is: &quot; &lt;&lt; standard_deviation &lt;&lt; std::endl;</code></pre>
<h4 id="task-2.2-1">Task 2.2</h4>
<p>The factorial is calculated using a do-while loop.</p>
<pre><code>do {
factorial_result *= current_number;
current_number++;
} while (current_number &lt;= input_number);</code></pre>
<p>The calculated factorial is outputted to the console.</p>
<pre><code>std::cout &lt;&lt; &quot;The factorial of &quot; &lt;&lt; input_number &lt;&lt; &quot; is: &quot; &lt;&lt; factorial_result &lt;&lt; std::endl;</code></pre>
<h3 id="algorithms-babylonian-square-root">Algorithms: Babylonian Square Root</h3>
<h4 id="task-3.1-1">Task 3.1</h4>
<p>The user is prompted to input a number.</p>
<pre><code>double number = 0;
std::cout &lt;&lt; &quot;Enter a number: &quot;;
std::cin &gt;&gt; number;</code></pre>
<p>The square root is calculated and outputted to the console.</p>
<pre><code>double square_root = babylonian_square_root(number);
std::cout &lt;&lt; &quot;The square root of &quot; &lt;&lt; number &lt;&lt; &quot; is &quot; &lt;&lt; square_root &lt;&lt; std::endl;</code></pre>
<h3 id="coursework-variable-manipulation">Coursework: Variable Manipulation</h3>
<h4 id="task-6.0">Task 6.0</h4>
<p>Include the necessary libraries.</p>
<pre><code>#include &lt;cmath&gt;
#include &lt;iostream&gt;</code></pre>
<h4 id="task-6.1">Task 6.1</h4>
<p>Declare the variables with their respective data types.</p>
<pre><code>int x = 25;
int y = 18;
double pay_rate = 12.50;
int first_number = 10;
int temporary_number = first_number;</code></pre>
<h4 id="task-6.2">Task 6.2</h4>
<p>Swap the values of x and y using a temporary variable.</p>
<pre><code>int temporary_x = x;
x = y;
y = temporary_x;</code></pre>
<h4 id="task-6.3">Task 6.3</h4>
<p>Output the values of x and y and evaluate the expression.</p>
<pre><code>std::cout &lt;&lt; &quot;The value of x is: &quot; &lt;&lt; x &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;The value of y is: &quot; &lt;&lt; y &lt;&lt; std::endl;
double evaluated_expression = (x + 12) / (y - 18 + pow(x, 3)); // Unsure if correct expression
std::cout &lt;&lt; &quot;Substituting these values into the expression (x + 12) / (y - 18 + x^3) gives: &quot;
&lt;&lt; evaluated_expression &lt;&lt; std::endl;</code></pre>
<h2 id="week-6-2024-11-04-to-2024-11-11"><strong>Week 6</strong> ‚Äì 2024-11-04 to 2024-11-11</h2>
<p><strong>What did you learn in the lab tasks this week?</strong></p>
<p>‚Ä¶</p>
<p><strong>How well did I learn it?</strong></p>
<p>‚Ä¶</p>
<p><strong>How does my solution compare with the official solution?</strong></p>
<p>‚Ä¶</p>
<p><strong>How can I extend the concepts used in the tasks to form a new project</strong></p>
<p>‚Ä¶</p>
<h3 id="control-structures-for-loops">Control Structures: For Loops</h3>
<pre><code>/**
 * @file l01-control_structures-for_loops.cpp
 * @author William Fayers (william@fayers.com)
 * @brief Explore the for loop in C++
 * @version 0.1.0
 * @date 2024-11-18
 * 
 * @copyright Copyright (c) 2024
 * 
 */
#include &lt;iostream&gt;

void even_odd_printer(int count_limit) {
    for (int count = 0; count &lt; count_limit; count++) {
        if (count % 2 == 0) {
            std::cout &lt;&lt; count &lt;&lt; &quot; is even&quot; &lt;&lt; std::endl;
        } else {
            std::cout &lt;&lt; count &lt;&lt; &quot; is odd&quot; &lt;&lt; std::endl;
        }
    }
}

void geometric_progression(int count_limit) {
    for (int count = 0; count &lt; count_limit; count++) {
        std::cout &lt;&lt; &quot;2^&quot; &lt;&lt; count &lt;&lt; &quot; = &quot; &lt;&lt; (1 &lt;&lt; count) &lt;&lt; std::endl;
    }
}

void sum_of_cubes(int count_limit) {
    int sum = 0;
    for (int count = 0; count &lt; count_limit; count++) {
        sum += count * count * count;
    }
    std::cout &lt;&lt; &quot;The sum of the cubes of the first &quot; &lt;&lt; count_limit &lt;&lt; &quot; numbers is &quot; &lt;&lt; sum &lt;&lt; std::endl;
}

void fibonacci(int count_limit) {
    int number_1 = 0;
    int number_2 = 1;
    for (int count = 0; count &lt; count_limit; count++) {
        std::cout &lt;&lt; number_1 &lt;&lt; std::endl;

        // Swap the numbers to get the next number in the sequence
        int temp = number_1;
        number_1 = number_2;
        number_2 += temp;
    }
}

int main() {
    // even_odd_printer(10);
    // geometric_progression(10);
    // sum_of_cubes(10);
    fibonacci(10);
    return 0;
}</code></pre>
<h3 id="functions-introduction">Functions: Introduction</h3>
<pre><code>/**
 * @file l02-functions-introduction.cpp
 * @author William Fayers (william@fayers.com)
 * @brief Explore functions in C++
 * @version 0.1.0
 * @date 2024-11-18
 * 
 * @copyright Copyright (c) 2024
 * 
 */
#include &lt;iostream&gt;
#include &lt;cmath&gt;</code></pre>
<h2 id="week-7-2024-11-11-to-2024-11-18"><strong>Week 7</strong> ‚Äì 2024-11-11 to 2024-11-18</h2>
<p>Some questions answers in LAB tasks:</p>
<p>Here are the answers to your questions about pointers and functions in C++:</p>
<ol type="1">
<li><p><strong>What is a pointer in C++?</strong> A pointer in C++ is a variable that stores the memory address of another variable. Pointers are used for dynamic memory allocation, arrays, and for passing large structures or classes to functions efficiently.</p></li>
<li><p><strong>How do you declare a pointer in C++?</strong> To declare a pointer in C++, you use the asterisk (*) symbol. For example:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true"></a><span class="dt">int</span>* ptr; <span class="co">// Declares a pointer to an integer</span></span></code></pre></div></li>
<li><p><strong>Explain the concept of the ‚Äúnull pointer.‚Äù</strong> A null pointer is a pointer that does not point to any valid memory location. It is often used to indicate that the pointer is not currently assigned to any object or variable. In C++, you can assign a pointer to null using:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a><span class="dt">int</span>* ptr = <span class="kw">nullptr</span>; <span class="co">// C++11 and later</span></span></code></pre></div></li>
<li><p><strong>What is the difference between pass-by-value and pass-by-reference in function parameters?</strong></p>
<ul>
<li><strong>Pass-by-value</strong> means that a copy of the actual parameter is passed to the function. Changes made to the parameter inside the function do not affect the original argument.</li>
<li><strong>Pass-by-reference</strong> means that a reference (or alias) to the actual parameter is passed to the function. Changes made to the parameter inside the function will affect the original argument.</li>
</ul></li>
<li><p><strong>Define a function in C++ that calculates the factorial of a number using recursion.</strong> Here is an example of a recursive function to calculate the factorial:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true"></a><span class="dt">int</span> factorial(<span class="dt">int</span> n) {</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true"></a>    <span class="cf">if</span> (n &lt;= <span class="dv">1</span>) {</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">1</span>; <span class="co">// Base case</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true"></a>    }</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true"></a>    <span class="cf">return</span> n * factorial(n - <span class="dv">1</span>); <span class="co">// Recursive case</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true"></a>}</span></code></pre></div></li>
<li><p><strong>What is the purpose of the <code>const</code> keyword in function declarations?</strong> The <code>const</code> keyword in function declarations is used to indicate that a parameter or member function will not modify the value of the variable or object it refers to. For example, a <code>const</code> parameter prevents the function from changing the argument passed to it, and a <code>const</code> member function cannot modify the object‚Äôs member variables.</p></li>
<li><p><strong>How do you return multiple values from a function in C++?</strong> You can return multiple values from a function in C++ using several methods:</p>
<ul>
<li>Using <code>std::pair</code> or <code>std::tuple</code> to return multiple values.</li>
<li>Using output parameters (pass-by-reference).</li>
<li>Using a struct or class to encapsulate the return values.</li>
</ul>
<p>Example using <code>std::pair</code>:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true"></a><span class="bu">std::</span>pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; getValues() {</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">std::</span>make_pair(<span class="dv">1</span>, <span class="dv">2</span>);</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true"></a>}</span></code></pre></div></li>
<li><p><strong>Explain the difference between <code>void*</code> and other pointer types.</strong> A <code>void*</code> pointer is a special type of pointer that can point to any data type, but it does not have a specific type associated with it. This means you cannot dereference a <code>void*</code> pointer directly without casting it to another pointer type. Other pointer types (like <code>int*</code>, <code>char*</code>, etc.) are strongly typed, meaning they are associated with a specific data type, allowing for direct dereferencing and type-safe operations.</p></li>
</ol>
<h3 id="pointers-introduction">Pointers: Introduction</h3>
<pre><code>/**
 * @file l01-pointers-introduction.cpp
 * @author William Fayers (william@fayers.com)
 * @brief Introduction to pointers in C++
 * @version 0.1.0
 * @date 2024-11-18
 * 
 * @copyright Copyright (c) 2024
 * 
 */
#include &lt;iostream&gt;

void pointer_example1() {
    // Declare two integers
    int number_1 = 8, number_2 = 16;

    // Declare two pointers to integers
    int* p_number_1 = &amp;number_1;
    int* p_number_2 = &amp;number_2;

    // Output addresses of the two integers
    std::cout &lt;&lt; &quot;Address of number_1: &quot; &lt;&lt; &amp;number_1 &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Address of number_2: &quot; &lt;&lt; &amp;number_2 &lt;&lt; std::endl;

    // Output stored addresses of the two pointers
    std::cout &lt;&lt; &quot;Address stored in p_number_1: &quot; &lt;&lt; p_number_1 &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Address stored in p_number_2: &quot; &lt;&lt; p_number_2 &lt;&lt; std::endl;

    // Output values stored at the addresses stored in the pointers
    std::cout &lt;&lt; &quot;Value stored at address stored in p_number_1: &quot; &lt;&lt; *p_number_1 &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Value stored at address stored in p_number_2: &quot; &lt;&lt; *p_number_2 &lt;&lt; std::endl;
}

void write_output(int* value) {
    std::cout &lt;&lt; &quot;Value stored at address: &quot; &lt;&lt; *value &lt;&lt; std::endl;
}

void compute_triple(int* value) {
    *value *= 3;
}

void pointer_example2() {
    int number = 5;
    int* p_number = &amp;number;
    
    write_output(p_number);
    *p_number += 15;
    write_output(p_number);
    compute_triple(p_number);
    write_output(p_number);
}

int main() {
    // pointer_example1();
    pointer_example2();

    return 0;
}</code></pre>
<h3 id="pointers-quadratic-calculator">Pointers: Quadratic Calculator</h3>
<pre><code>/**
 * @file l02-pointers-quadratic_calculator.cpp
 * @author William Fayers (william@fayers.com)
 * @brief Quadratic calculator using pointers in C++
 * @version 0.1.0
 * @date 2024-11-18
 * 
 * @copyright Copyright (c) 2024
 * 
 */
#include &lt;iostream&gt;
#include &lt;cmath&gt;

bool solve_quadratic(float a, float b, float c, float* x1, float* x2) {
    float discriminant = b * b - 4 * a * c;
    if (discriminant &lt; 0) {
        *x1 = -b / (2 * a); // Real part
        *x2 = sqrt(-discriminant) / (2 * a); // Imaginary part
        return false; // No real roots
    }

    *x1 = (-b + sqrt(discriminant)) / (2 * a);
    *x2 = (-b - sqrt(discriminant)) / (2 * a);
    return true; // Real roots
}

int main() {
    float a, b, c;
    std::cout &lt;&lt; &quot;Enter a, b, and c: &quot;;
    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

    std::cout &lt;&lt; &quot;Solving &quot; &lt;&lt; a &lt;&lt; &quot;x^2 + &quot; &lt;&lt; b &lt;&lt; &quot;x + &quot; &lt;&lt; c &lt;&lt; &quot; = 0&quot; &lt;&lt; std::endl;

    float x1, x2;
    if (solve_quadratic(a, b, c, &amp;x1, &amp;x2)) {
        if (x1 == x2) {
            std::cout &lt;&lt; &quot;Root of the auxillary equation: &quot; &lt;&lt; x1 &lt;&lt; std::endl;
            std::cout &lt;&lt; &quot;Solution of the homogenous equation: y = C1 * e^(&quot; &lt;&lt; x1
                        &lt;&lt; &quot;x) + C2 * x * e^(&quot; &lt;&lt; x1 &lt;&lt; &quot;x)&quot; &lt;&lt; std::endl;
        } else {
            std::cout &lt;&lt; &quot;Roots of the auxillary equation: &quot; &lt;&lt; x1 &lt;&lt; &quot;, &quot; &lt;&lt; x2 &lt;&lt; std::endl;
            std::cout &lt;&lt; &quot;Solution of the homogenous equation: y = C1 * e^(&quot; &lt;&lt; x1
                        &lt;&lt; &quot;x) + C2 * e^(&quot; &lt;&lt; x2 &lt;&lt; &quot;x)&quot; &lt;&lt; std::endl;
        }
    } else {
        std::cout &lt;&lt; &quot;Roots of the auxillary equation: &quot; &lt;&lt; x1 &lt;&lt; &quot; + &quot; &lt;&lt; x2 &lt;&lt; &quot;i, &quot; &lt;&lt; x1
                    &lt;&lt; &quot; - &quot; &lt;&lt; x2 &lt;&lt; &quot;i&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;Solution of the homogenous equation: y = C1 * e^(&quot; &lt;&lt; x1
                    &lt;&lt; &quot;x) * cos(&quot; &lt;&lt; x2 &lt;&lt; &quot;x) + C2 * e^(&quot; &lt;&lt; x1 &lt;&lt; &quot;x) * sin(&quot; &lt;&lt; x2 &lt;&lt; &quot;x)&quot; &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
<h2 id="week-8-2024-11-18-to-2024-11-25"><strong>Week 8</strong> ‚Äì 2024-11-18 to 2024-11-25</h2>
<p>‚Ä¶</p>
<h3 id="applications-quadratic-calculator">Applications: Quadratic Calculator</h3>
<pre><code>/**
 * @file l01-applications-quadratic_calculator.cpp
 * @author William Fayers (william@fayers.com)
 * @brief Applying C++ to solve quadratic equations
 * @version 0.1.0
 * @date 2024-12-07
 *
 * @copyright Copyright (c) 2024
 *
 */
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;cctype&gt;

/**
 * @brief Class representing a quadratic equation.
 *
 */
class QuadraticEquation
{
private:
    long double a;
    long double b;
    long double c;

public:
    // Constructor
    QuadraticEquation(long double coeff_a, long double coeff_b, long double coeff_c)
    {
        if (std::isnan(coeff_a) || std::isnan(coeff_b) || std::isnan(coeff_c))
        {
            throw std::invalid_argument(&quot;Coefficients must be valid numbers.&quot;);
        }
        a = coeff_a;
        b = coeff_b;
        c = coeff_c;
    }

    /**
     * @brief Solves the equation, which could be quadratic or linear.
     *
     * @return std::pair&lt;std::complex&lt;long double&gt;, std::complex&lt;long double&gt;&gt; Pair of roots.
     * If linear, returns one root and NaN for the second.
     * If infinitely many solutions, both roots are represented as NaN.
     */
    std::pair&lt;std::complex&lt;long double&gt;, std::complex&lt;long double&gt;&gt; solve() const
    {
        if (a != 0.0L)
        {
            // Quadratic case
            long double discriminant = b * b - 4.0L * a * c;

            // Check for potential overflow/underflow
            if (std::isinf(discriminant))
            {
                throw std::overflow_error(&quot;Discriminant is too large, causing overflow.&quot;);
            }

            // Using complex numbers to handle real and complex roots
            std::complex&lt;long double&gt; sqrt_discriminant = std::sqrt(std::complex&lt;long double&gt;(discriminant, 0));

            // Calculate two roots
            std::complex&lt;long double&gt; two_a = 2.0L * a;
            std::complex&lt;long double&gt; root1 = (-b + sqrt_discriminant) / two_a;
            std::complex&lt;long double&gt; root2 = (-b - sqrt_discriminant) / two_a;

            return std::make_pair(root1, root2);
        }
        else if (b != 0.0L)
        {
            // Linear case: bx + c = 0 =&gt; x = -c / b
            std::complex&lt;long double&gt; root = -c / b;
            return std::make_pair(root, std::complex&lt;long double&gt;(NAN, NAN));
        }
        else
        {
            if (c == 0.0L)
            {
                // Infinite solutions: 0 = 0
                return std::make_pair(std::complex&lt;long double&gt;(INFINITY, 0.0L),
                                      std::complex&lt;long double&gt;(INFINITY, 0.0L));
            }
            else
            {
                // No solution: c = 0 where c != 0
                return std::make_pair(std::complex&lt;long double&gt;(NAN, NAN),
                                      std::complex&lt;long double&gt;(NAN, NAN));
            }
        }
    }

    /**
     * @brief Formats the equation as a string.
     *
     * @return std::string Representation of the equation.
     */
    std::string to_string() const
    {
        std::ostringstream equation;
        bool first = true;

        // Format a*x^2
        if (a != 0.0L)
        {
            equation &lt;&lt; a &lt;&lt; &quot;x^2 &quot;;
            first = false;
        }

        // Format b*x
        if (b != 0.0L)
        {
            if (!first &amp;&amp; b &gt; 0)
            {
                equation &lt;&lt; &quot;+ &quot;;
            }
            else if (b &lt; 0)
            {
                equation &lt;&lt; &quot;- &quot;;
            }
            equation &lt;&lt; std::abs(b) &lt;&lt; &quot;x &quot;;
            first = false;
        }

        // Format c
        if (c != 0.0L || first)
        { // Display &#39;0&#39; if all coefficients are zero
            if (!first &amp;&amp; c &gt; 0)
            {
                equation &lt;&lt; &quot;+ &quot;;
            }
            else if (c &lt; 0)
            {
                equation &lt;&lt; &quot;- &quot;;
            }
            equation &lt;&lt; std::abs(c) &lt;&lt; &quot; &quot;;
        }

        equation &lt;&lt; &quot;= 0&quot;;
        return equation.str();
    }
};

/**
 * @brief Safely reads a number from the user with validation and limited attempts.
 *
 * @param prompt Prompt to display to the user.
 * @param number Reference to store the validated number.
 * @param max_attempts Maximum number of invalid attempts allowed (default is 5).
 * @return bool True if a valid number was read, False otherwise.
 */
bool read_number(const std::string &amp;prompt, long double &amp;number, int max_attempts = 5)
{
    int attempts = 0;
    while (attempts &lt; max_attempts)
    {
        std::cout &lt;&lt; prompt;
        std::string input;
        std::getline(std::cin, input);
        std::stringstream ss(input);
        ss &gt;&gt; number;

        // Check if entire input was consumed and was a valid number
        if (!ss.fail() &amp;&amp; ss.eof())
        {
            return true;
        }
        else
        {
            std::cerr &lt;&lt; &quot;Invalid input. Please enter a valid number.&quot; &lt;&lt; std::endl;
            attempts++;
        }
    }
    std::cerr &lt;&lt; &quot;Maximum invalid attempts reached. Exiting input process.&quot; &lt;&lt; std::endl;
    return false;
}

/**
 * @brief Formats a complex number as a string in the form &quot;a + bi&quot;.
 *
 * @param num The complex number to format.
 * @return std::string The formatted string.
 */
std::string format_complex(const std::complex&lt;long double&gt; &amp;num)
{
    if (std::isnan(num.real()) &amp;&amp; std::isnan(num.imag()))
    {
        return &quot;No Solution.&quot;;
    }
    if (std::isinf(num.real()) &amp;&amp; std::isinf(num.imag()))
    {
        return &quot;Infinite Solutions.&quot;;
    }

    std::ostringstream oss;
    oss &lt;&lt; num.real();

    if (num.imag() &gt;= 0.0L)
    {
        oss &lt;&lt; &quot; + &quot; &lt;&lt; num.imag() &lt;&lt; &quot;i&quot;;
    }
    else
    {
        oss &lt;&lt; &quot; - &quot; &lt;&lt; std::abs(num.imag()) &lt;&lt; &quot;i&quot;;
    }

    return oss.str();
}

/**
 * @brief Main function to run the Quadratic Solver.
 *
 * @return int
 */
int main()
{
    std::cout &lt;&lt; &quot;=====================================&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;          Quadratic Solver           &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;=====================================&quot; &lt;&lt; std::endl;

    std::vector&lt;std::string&gt; equation_log; // To keep track of all solved equations
    char continue_calculating = &#39;y&#39;;

    while (std::tolower(continue_calculating) == &#39;y&#39;)
    {
        try
        {
            long double a, b, c;

            // Read coefficients with validation
            if (!read_number(&quot;Enter coefficient a (a can be 0 for linear equations): &quot;, a))
            {
                throw std::runtime_error(&quot;Failed to read coefficient &#39;a&#39;.&quot;);
            }
            if (!read_number(&quot;Enter coefficient b: &quot;, b))
            {
                throw std::runtime_error(&quot;Failed to read coefficient &#39;b&#39;.&quot;);
            }
            if (!read_number(&quot;Enter coefficient c: &quot;, c))
            {
                throw std::runtime_error(&quot;Failed to read coefficient &#39;c&#39;.&quot;);
            }

            // Create a QuadraticEquation object
            QuadraticEquation equation(a, b, c);

            // Display the equation
            std::cout &lt;&lt; &quot;\nSolving the equation: &quot; &lt;&lt; equation.to_string() &lt;&lt; std::endl;

            // Solve the equation
            auto roots = equation.solve();

            // Prepare solution string
            std::string solution;
            if (a != 0.0L)
            {
                // Quadratic case
                long double discriminant = b * b - 4.0L * a * c;
                if (discriminant &gt; 0.0L)
                {
                    // Two distinct real roots
                    solution = &quot;x1 = &quot; + format_complex(roots.first) + &quot;, x2 = &quot; + format_complex(roots.second);
                }
                else if (discriminant == 0.0L)
                {
                    // One repeated real root
                    solution = &quot;x = &quot; + format_complex(roots.first);
                }
                else
                {
                    // Complex roots
                    solution = &quot;x1 = &quot; + format_complex(roots.first) + &quot;, x2 = &quot; + format_complex(roots.second);
                }
            }
            else
            {
                // Linear or no/infinite solutions
                if (b != 0.0L)
                {
                    solution = &quot;x = &quot; + format_complex(roots.first);
                }
                else
                {
                    if (c == 0.0L)
                    {
                        solution = &quot;Infinite solutions.&quot;;
                    }
                    else
                    {
                        solution = &quot;No solution.&quot;;
                    }
                }
            }

            // Display the roots
            std::cout &lt;&lt; &quot;Solution: &quot; &lt;&lt; solution &lt;&lt; &quot;\n&quot;
                      &lt;&lt; std::endl;

            // Log the equation and solution
            equation_log.push_back(&quot;Equation: &quot; + equation.to_string() + &quot; | Solution: &quot; + solution);
        }
        catch (const std::exception &amp;ex)
        {
            std::cerr &lt;&lt; &quot;An error occurred: &quot; &lt;&lt; ex.what() &lt;&lt; &quot;\n&quot;
                      &lt;&lt; std::endl;
        }

        // Continuation prompt with validation
        while (true)
        {
            std::cout &lt;&lt; &quot;Would you like to solve another equation? (y/n): &quot;;
            std::cin &gt;&gt; continue_calculating;
            std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;); // Clear input buffer

            continue_calculating = std::tolower(continue_calculating);
            if (continue_calculating == &#39;y&#39; || continue_calculating == &#39;n&#39;)
            {
                break;
            }
            else
            {
                std::cerr &lt;&lt; &quot;Invalid response. Please enter &#39;y&#39; for yes or &#39;n&#39; for no.&quot; &lt;&lt; std::endl;
            }
        }

        std::cout &lt;&lt; std::endl;
    }

    // Optionally, display the log of all equations solved
    if (!equation_log.empty())
    {
        std::cout &lt;&lt; &quot;=====================================&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;          Solved Equations           &quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;=====================================&quot; &lt;&lt; std::endl;
        for (size_t i = 0; i &lt; equation_log.size(); ++i)
        {
            std::cout &lt;&lt; i + 1 &lt;&lt; &quot;. &quot; &lt;&lt; equation_log[i] &lt;&lt; std::endl;
        }
        std::cout &lt;&lt; &quot;=====================================&quot; &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; &quot;Thank you for using the Quadratic Solver.&quot; &lt;&lt; std::endl;
    return 0;
}</code></pre>
<h3 id="applications-maclaurin">Applications: Maclaurin</h3>
<pre><code>/**
 * @file l02-applications-maclaurin.cpp
 * @author William Fayers (william@fayers.com)
 * @brief Calculating the Maclaurin series of functions using C++
 * @version 0.1.0
 * @date 2024-12-08
 *
 * @copyright Copyright (c) 2024
 *
 */
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;limits&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

// Function 1: \frac{1}{\pi + x}
// Function 2: \ln(3 + x)

/**
 * @brief Function to calculate the Maclaurin series of \frac{1}{\pi + x}.
 *
 * @param x Value of x.
 * @param terms_to_calculate Number of terms to calculate.
 * @return double Maclaurin series value.
 */
double maclaurin_series_1(double x, int terms_to_calculate)
{
    double sum = 0.0;
    for (int term = 0; term &lt; terms_to_calculate; ++term)
    {
        sum += std::pow(-1, term) * std::pow(x / M_PI, term) / M_PI;
    }
    return sum;
}

/**
 * @brief Function to calculate the Maclaurin series of \ln(3 + x).
 *
 * @param x Value of x.
 * @param terms_to_calculate Number of terms to calculate.
 * @return double Maclaurin series value.
 */
double maclaurin_series_2(double x, int terms_to_calculate)
{
    double sum = std::log(3.0);
    for (int term = 1; term &lt;= terms_to_calculate; ++term)
    {
        sum += std::pow(-1, term + 1) * std::pow(x / 3.0, term) / term;
    }
    return sum;
}

/**
 * @brief Function to display the Maclaurin series of a function.
 *
 * @param x Value of x.
 * @param terms_to_calculate Number of terms to calculate.
 */
void display_maclaurin_series(double x, int terms_to_calculate)
{
    std::cout &lt;&lt; &quot;Calculating the Maclaurin series of 1/(pi + x) at x = &quot; &lt;&lt; x
              &lt;&lt; &quot; with &quot; &lt;&lt; terms_to_calculate &lt;&lt; &quot; terms.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; maclaurin_series_1(x, terms_to_calculate) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Expected: &quot; &lt;&lt; 1.0 / (M_PI + x) &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;Calculating the Maclaurin series of ln(3 + x) at x = &quot; &lt;&lt; x
              &lt;&lt; &quot; with &quot; &lt;&lt; terms_to_calculate &lt;&lt; &quot; terms.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; maclaurin_series_2(x, terms_to_calculate) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Expected: &quot; &lt;&lt; std::log(3 + x) &lt;&lt; std::endl;
}

/**
 * @brief Main function to run the Maclaurin series calculator.
 *
 * @return int
 */
int main()
{
    display_maclaurin_series(0.5, 100);
}</code></pre>
<h3 id="applications-array-copy-check">Applications: Array Copy Check</h3>
<pre><code>/**
 * @file l03-applications-array_copy_check.cpp
 * @author William Fayers (william@fayers.com)
 * @brief Duplicate an array and check if the copy is correct.
 * @version 0.1.0
 * @date 2024-12-08
 *
 * @copyright Copyright (c) 2024
 *
 */
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;iterator&gt;

/**
 * @brief Function to duplicate an array using std::copy.
 *
 * @param arr Array to duplicate.
 * @return std::vector&lt;int&gt; Duplicated array.
 */
std::vector&lt;int&gt; duplicate_array(const std::vector&lt;int&gt; &amp;arr)
{
    std::vector&lt;int&gt; copy(arr.size());
    std::copy(arr.begin(), arr.end(), copy.begin());
    return copy;
}

/**
 * @brief Function to check if two arrays are equal.
 *
 * @param arr1 First array.
 * @param arr2 Second array.
 * @return bool True if arrays are equal, False otherwise.
 */
bool arrays_equal(const std::vector&lt;int&gt; &amp;arr1, const std::vector&lt;int&gt; &amp;arr2)
{
    return arr1 == arr2;
}

/**
 * @brief Main function to duplicate an array and check if the copy is correct.
 *
 * @return int
 */
int main()
{
    std::vector&lt;int&gt; original_array = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; copied_array = duplicate_array(original_array);

    // Display the original and copied arrays
    std::cout &lt;&lt; &quot;Original Array: &quot;;
    std::copy(original_array.begin(), original_array.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));
    std::cout &lt;&lt; &quot;\n&quot;;

    std::cout &lt;&lt; &quot;Copied Array: &quot;;
    std::copy(copied_array.begin(), copied_array.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));
    std::cout &lt;&lt; &quot;\n&quot;;

    // Check if the arrays are equal
    if (arrays_equal(original_array, copied_array))
    {
        std::cout &lt;&lt; &quot;The copied array is correct.&quot; &lt;&lt; std::endl;
    }
    else
    {
        std::cout &lt;&lt; &quot;The copied array is incorrect.&quot; &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
<h2 id="week-9-2024-11-25-to-2024-12-02"><strong>Week 9</strong> ‚Äì 2024-11-25 to 2024-12-02</h2>
<p>‚Ä¶</p>
<h3 id="file-handling-overview">File Handling: Overview</h3>
<pre><code>/**
 * @file l01-file_handling-overview.cpp
 * @author William Fayers (william@fayers.com)
 * @brief Reading/writing to a file in C++
 * @version 0.1.0
 * @date 2024-12-08
 *
 * @copyright Copyright (c) 2024
 *
 */
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

/**
 * @brief Function to write a vector of strings to a file.
 *
 * @param filename Name of the file to write to.
 * @param data Vector of strings to write to the file.
 */
void write_to_file(const std::string &amp;filename, const std::vector&lt;std::string&gt; &amp;data)
{
    std::ofstream file(filename);
    if (!file.is_open())
    {
        throw std::runtime_error(&quot;Failed to open file for writing.&quot;);
    }

    for (const std::string &amp;line : data)
    {
        file &lt;&lt; line &lt;&lt; std::endl;
    }

    file.close();
}

/**
 * @brief Reads a file and returns the contents as a vector of strings.
 *
 * @param filename Name of the file to read.
 * @return std::vector&lt;std::string&gt; Contents of the file.
 */
std::vector&lt;std::string&gt; read_from_file(const std::string &amp;filename)
{
    std::vector&lt;std::string&gt; data;
    std::ifstream file(filename);
    if (!file.is_open())
    {
        throw std::runtime_error(&quot;Failed to open file for reading.&quot;);
    }

    std::string line;
    while (std::getline(file, line))
    {
        data.push_back(line);
    }

    file.close();
    return data;
}

/**
 * @brief Main function to write/read to a file.
 *
 * @return int
 */
int main()
{
    std::vector&lt;std::string&gt; data = {
        &quot;Hello, World!&quot;,
        &quot;This is a test file.&quot;,
        &quot;Writing to a file in C++ is easy.&quot;,
        &quot;This is the last line of the file.&quot;};

    std::string filename = &quot;output.txt&quot;;
    write_to_file(filename, data);

    std::cout &lt;&lt; &quot;Data written to file: &quot; &lt;&lt; filename &lt;&lt; std::endl;

    std::vector&lt;std::string&gt; read_data = read_from_file(filename);

    std::cout &lt;&lt; &quot;Data read from file: &quot; &lt;&lt; filename &lt;&lt; std::endl;

    for (const std::string &amp;line : read_data)
    {
        std::cout &lt;&lt; line &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
<h2 id="references">üìì References</h2>
<p>[1] ‚ÄúA comprehensive guide to C++ coding standards and best practices,‚Äù <em>C++ Style Guide</em>, 2024. [Online] Available: https://google.github.io/styleguide/cppguide.html (accessed 2024-10-05).</p>
<p>[2] ‚ÄúOfficial documentation for Doxygen‚Äôs documentation blocks and usage,‚Äù <em>Doxygen Manual - Documentation Blocks</em>, 2024. [Online] Available: https://www.doxygen.nl/manual/docblocks.html (accessed 2024-10-05).</p>
